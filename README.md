# Database Migration with Liquibase
This is a Spring Boot application with Liquibase to manage the database migration.

These are some steps to guide the whole procedure:



# Add the Liquibase dependencies:

To add the Liquibase into the project, open the `build.gradle` file and add it to the `classpath`:

```
buildscript {
	ext {
		springBootVersion = '1.5.8.RELEASE'
	}
	repositories {
		mavenCentral()
		mavenLocal()
	}
	dependencies {
		classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")

		classpath "org.liquibase:liquibase-gradle-plugin:1.2.4"
	}
}
```



At the same file, add the Liquibase dependency:

```
dependencies {
	compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.5.8.RELEASE'

	compile group: 'org.liquibase', name: 'liquibase-core', version: '3.5.3'
}
```



# Configure the Liquibase properties:

To avoid the Liquibase task execution during the application startup, open the `application.properties` file and add the following configuration on it:

```
liquibase.enabled=false
```



# Create the Liquibase activity:

To create the Liquibase activity, open the `build.gradle` file and add a new section on it:

```
liquibase {
	activities {
		main {
			changeLogFile 'src/main/db/changelog.xml'
			url 'jdbc:mariadb://localhost:3306/testliquibase'
            username 'root'
            password 'root'

            referenceUrl 'jdbc:mariadb://localhost:3306/testliquibase_reference'
            referenceUsername 'root'
            referencePassword 'root'
		}
	}

	runList = 'main'
}
```



These are the parameters:

* `changeLogFile`: the XML file where the change sets will be created by Liquibase;
* `url`: the database **destination** address where the changes must be applied/compared;
* `username`: the username of the **destination** database where the changes must be applied/compared;
* `password`: the password of the **destination** database where the changes must be applied/compared;
* `referenceUrl`: the address of the reference database where the changes where performed;
* `referenceUsername`: the username of the reference database where the changes where performed;
* `referencePassword`: the password of the reference database where the changes where performed.



# Add an entity model:

Add an entity model into the application, for instance:

```java
@Entity
public class Product {

    @Id
    @GeneratedValue(strategy= GenerationType.AUTO)
    private long id;

    @Column(length = 30, nullable = false)
    private String name;

    @Column(length = 30, nullable = false)
    private String model;

    @Column(nullable = false)
    private double price;
    
    //Getters and Setters
}
```



# Execute the Liquibase tasks: 

There are two main tasks to be performed in case of model creation or changes:



## Populate the change log XML file:

To populate the change log XML file with the changes from the models, execute the **diffChangeLog** task. This task will populate the **change log file** with the last changes, comparing the reference database with the base database schemas. These a example related to the creation of the `Product` entity:

```XML
    <changeSet author="paulo.cesar (generated)" id="1516704417378-1">
        <createTable tableName="product">
            <column autoIncrement="true" name="id" type="BIGINT">
                <constraints primaryKey="true"/>
            </column>
            <column name="model" type="VARCHAR(30)">
                <constraints nullable="false"/>
            </column>
            <column name="name" type="VARCHAR(30)">
                <constraints nullable="false"/>
            </column>
            <column name="price" type="DOUBLE">
                <constraints nullable="false"/>
            </column>
        </createTable>
    </changeSet>

```



The `id` parameter at the `changeSet` section must be used to uniquely identify the change set.

When more changes where performed in certain entity model, execute the **diffChangeLog** task again, to append one more change set at this file.



## Generate the SQL statements to perform the changes:

To generate the SQL statements to perform the changes, execute the **updateSQL** task. The SQL statements will be printed at execution log.



# Update the DDL scripts:

Use the SQL statements generated by the **updateSQL** task to update the DDL scripts.